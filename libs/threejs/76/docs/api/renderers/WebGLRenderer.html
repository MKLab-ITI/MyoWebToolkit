<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<base href="../../" />
		<script src="list.js"></script>
		<script src="page.js"></script>
		<link type="text/css" rel="stylesheet" href="page.css" />
	</head>
	<body>
		<h1>[name]</h1>

		<div class="desc">The WebGL renderer displays your beautifully crafted scenes using WebGL, if your device supports it.</div>
		<div class="desc">This renderer has way better performance than [page:CanvasRenderer].</div>


		<h2>Constructor</h2>


		<h3>[name]( [page:Object parameters] )</h3>

		<div>parameters is an optional object with properties defining the renderer's behaviour. The constructor also accepts no parameters at all. In all cases, it will assume sane defaults when parameters are missing.</div>

		<div>
		canvas — A [page:Canvas] where the renderer draws its output.<br />
		context — The [page:RenderingContext] context to use.<br />
		precision — Shader precision. Can be *"highp"*, *"mediump"* or *"lowp"*. Defaults to *"highp"* if supported by the device.<br />
		alpha — [page:Boolean], default is *false*.<br />
		premultipliedAlpha — [page:Boolean], default is *true*.<br />
		antialias — [page:Boolean], default is *false*.<br />
		stencil — [page:Boolean], default is *true*.<br />
		preserveDrawingBuffer — [page:Boolean], default is *false*.<br />
		depth — [page:Boolean], default is *true*.<br />
		logarithmicDepthBuffer — [page:Boolean], default is *false*.<br />
		</div>

		<h2>Properties</h2>

		<h3>[property:DOMElement domElement]</h3>

		<div>A [page:Canvas] where the renderer draws its output.<br />
		This is automatically created by the renderer in the constructor (if not provided already); you just need to add it to your page.</div>

		<h3>[property:WebGLRenderingContext context]</h3>

		<div>The HTML5 Canvas's 'webgl' context obtained from the canvas where the renderer will draw.</div>

		<h3>[property:Boolean autoClear]</h3>

		<div>Defines whether the renderer should automatically clear its output before rendering.</div>


		<h3>[property:Boolean autoClearColor]</h3>

		<div>If autoClear is true, defines whether the renderer should clear the color buffer. Default is true.</div>


		<h3>[property:Boolean autoClearDepth]</h3>

		<div>If autoClear is true, defines whether the renderer should clear the depth buffer. Default is true.</div>


		<h3>[property:Boolean autoClearStencil]</h3>

		<div>If autoClear is true, defines whether the renderer should clear the stencil buffer. Default is true.</div>


		<h3>[property:Boolean sortObjects]</h3>

		<div>Defines whether the renderer should sort objects. Default is true.</div>

		<div>Note: Sorting is used to attempt to properly render objects that have some degree of transparency.  By definition, sorting objects may not work in all cases.  Depending on the needs of application, it may be neccessary to turn off sorting and use other methods to deal with transparency rendering e.g. manually determining the object rendering order.</div>


		<h3>[property:Array clippingPlanes]</h3>

		<div>User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply globally. Points in space whose dot product with the plane is negative are cut away. Default is [].</div>

		<h3>[property:Boolean localClippingEnabled]</h3>

		<div>Defines whether the renderer respects object-level clipping planes. Default is false.</div>



		<h3>[property:Boolean gammaInput]</h3>

		<div>Default is false. If set, then it expects that all textures and colors are premultiplied gamma.</div>


		<h3>[property:Boolean gammaOutput]</h3>

		<div>Default is false.  If set, then it expects that all textures and colors need to be outputted in premultiplied gamma.</div>


		<h3>[property:Boolean shadowMapEnabled]</h3>

		<div>Default is false. If set, use shadow maps in the scene.</div>


		<h3>[property:Integer shadowMapType]</h3>

		<div>Defines shadow map type (unfiltered, percentage close filtering, percentage close filtering with bilinear filtering in shader)</div>
		<div>Options are THREE.BasicShadowMap, THREE.PCFShadowMap, THREE.PCFSoftShadowMap. Default is THREE.PCFShadowMap.</div>


		<h3>[property:Integer shadowMapCullFace]</h3>

		<div>Default is THREE.CullFaceFront. The faces that needed to be culled. Possible values: THREE.CullFaceFront and THREE.CullFaceBack</div>


		<h3>[property:Boolean shadowMapCascade]</h3>

		<div>Default is false. If Set, use cascaded shadowmaps. See [link:http://developer.download.nvidia.com/SDK/10.5/opengl/src/cascaded_shadow_maps/doc/cascaded_shadow_maps.pdf cascaded shadowmaps] for more information.</div>


		<h3>[property:Integer maxMorphTargets]</h3>

		<div>Default is 8. The maximum number of MorphTargets allowed in a shader. Keep in mind that the standard materials only allow 8 MorphTargets.</div>


		<h3>[property:Integer maxMorphNormals]</h3>

		<div>Default is 4. The maximum number of MorphNormals allowed in a shader. Keep in mind that the standard materials only allow 4 MorphNormals. </div>


		<h3>[property:Boolean autoScaleCubemaps]</h3>

		<div>Default is true. If set, then Cubemaps are scaled, when they are bigger than the maximum size, to make sure that they aren't bigger than the maximum size.</div>


		<h3>[property:Object info]</h3>

		<div>An object with a series of statistical information about the graphics board memory and the rendering process. Useful for debugging or just for the sake of curiosity. The object contains the following fields:</div>
		<div>
		<ul>
			<li>memory:
				<ul>
					<li>geometries</li>
					<li>textures</li>
				</ul>
			</li>
			<li>render:
				<ul>
					<li>calls</li>
					<li>vertices</li>
					<li>faces</li>
					<li>points</li>
				</ul>
			</li>
			<li>programs
			</li>
		</ul>
		</div>

		<h3>[property:WebGLShadowMap shadowMap]</h3>
		<div>
		This contains the reference to the component implementing shadow mapping.
		</div>


		<h2>Methods</h2>

		<h3>[method:WebGLRenderingContext getContext]()</h3>
		<div>
		Return the WebGL context.
		</div>

		<h3>[method:WebGLContextAttributes getContextAttributes]()</h3>
		<div>
		Returns an object that describes the attributes set on the WebGL context when it was created.
		</div>

		<h3>[method:Boolean supportsVertexTextures]()</h3>
		<div>
		Return a [page:Boolean] true if the context supports vertex textures.
		</div>

		<h3>[method:Object getSize]()</h3>
		<div>Returns an object containing the width and height of the renderer's output canvas, in pixels.</div>

		<h3>[method:null setSize]( [page:Integer width], [page:Integer height], [page:Boolean updateStyle] )</h3>
		<div>Resizes the output canvas to (width, height), and also sets the viewport to fit that size, starting in (0, 0). Setting updateStyle to true adds explicit pixel units to the output canvas style.</div>

		<h3>[method:null setViewport]( [page:Integer x], [page:Integer y], [page:Integer width], [page:Integer height] )</h3>
		<div>Sets the viewport to render from (x, y) to (x + width, y + height).</div>


		<h3>[method:null setScissor]( [page:Integer x], [page:Integer y], [page:Integer width], [page:Integer height] )</h3>
		<div>Sets the scissor area from (x, y) to (x + width, y + height).</div>

		<div>NOTE: The point (x, y) is the lower left corner of the area to be set for both of these methods. The area is defined from left to right in width but bottom to top in height. The sense of the vertical definition is opposite to the fill direction of an HTML canvas element.</div>

		<h3>[method:null setScissorTest]( [page:Boolean boolean] )</h3>
		<div>Enable or disable the scissor test. When this is enabled, only the pixels within the defined scissor area will be affected by further renderer actions.</div>

		<h3>[method:null setClearColor]( [page:Color color], [page:Float alpha] )</h3>
		<div>Sets the clear color and opacity.</div>

		<code>// Creates a renderer with red background
		var renderer = new THREE.WebGLRenderer();
		renderer.setSize( 200, 100 );
		renderer.setClearColor( 0xff0000 );
		</code>

		<h3>[method:Color getClearColor]()</h3>
		<div>Returns a [page:Color THREE.Color] instance with the current clear color.</div>

		<h3>[method:Float getClearAlpha]()</h3>
		<div>Returns a [page:Float float] with the current clear alpha. Ranges from 0 to 1.</div>

		<h3>[method:null clear]( [page:Boolean color], [page:Boolean depth], [page:Boolean stencil] )</h3>
		<div>Tells the renderer to clear its color, depth or stencil drawing buffer(s). This method initializes the color buffer to the current clear color value.</div>
		<div>Arguments default to true.</div>

		<h3>[method:null renderBufferImmediate]( [page:Object3D object], [page:shaderprogram program], [page:Material shading] )</h3>
		<div>object — an instance of [page:Object3D]]<br />
		program — an instance of shaderProgram<br />
		shading — an instance of Material<br />
		</div>
		<div>
		Render an immediate buffer. Gets called by renderImmediateObject.
		</div>


		<h3>[method:null renderBufferDirect]( [page:Camera camera], [page:Array lights], [page:Fog fog], [page:Material material], [page:Object geometryGroup], [page:Object3D object] )</h3>
		<div>Render a buffer geometry group using the camera and with the correct material.</div>


		<h3>[method:null renderBuffer]( [page:Camera camera], [page:Array lights], [page:Fog fog], [page:Material material], [page:Object geometryGroup], [page:Object3D object] )</h3>
		<div>Render a geometry group using the camera and with the correct material.</div>


		<h3>[method:null render]( [page:Scene scene], [page:Camera camera], [page:WebGLRenderTarget renderTarget], [page:Boolean forceClear] )</h3>
		<div>Render a scene using a camera.</div>
		<div>The render is done to the renderTarget (if specified) or to the canvas as usual.</div>
		<div>If forceClear is true, the depth, stencil and color buffers will be cleared before rendering even if the renderer's autoClear property is false.</div>
		<div>Even with forceClear set to true you can prevent certain buffers being cleared by setting either the .autoClearColor, .autoClearStencil or .autoClearDepth properties to false.</div>

		<h3>[method:null readRenderTargetPixels]( [page:WebGLRenderTarget renderTarget], [page:Float x], [page:Float y], [page:Float width], [page:Float height], buffer )</h3>
		<div>Reads the pixel data from the renderTarget into the buffer you pass in. Buffer should be a Javascript Uint8Array instantiated with new Uint8Array( renderTargetWidth * renderTargetWidth * 4 ) to account for size and color information. This is a wrapper around gl.readPixels.</div>

		<h3>[method:null renderImmediateObject]( camera, lights, fog, material, object )</h3>
		<div>Renders an immediate Object using a camera.</div>


		<h3>[method:null setFaceCulling]( cullFace, frontFace )</h3>
		<div>
		[page:String cullFace] —- "back", "front", "front_and_back", or false.<br />
		[page:String frontFace] —- "ccw" or "cw<br />
		</div>
		<div>Used for setting the gl frontFace, cullFace states in the GPU, thus enabling/disabling face culling when rendering.</div>
		<div>If cullFace is false, culling will be disabled.</div>


		<h3>[method:null setTexture]( [page:Texture texture], [page:number slot] )</h3>
		<div>
		texture -- The [page:Texture texture] that needs to be set.<br />
		slot -- The number indicating which slot should be used by the texture.
		</div>
		<div>
		This method sets the correct texture to the correct slot for the wegl shader. The slot number can be found as a value of the uniform of the sampler.
		</div>

		<h3>[method:null setRenderTarget]( [page:WebGLRenderTarget renderTarget] )</h3>
		<div>
		renderTarget -- The [page:WebGLRenderTarget renderTarget] that needs to be activated.<br />
		</div>
		<div>
		This method sets the active rendertarget.
		</div>

		<h3>[method:boolean supportsCompressedTextureS3TC]()</h3>
		<div>
		This method returns true if the webgl implementation supports compressed textures of the format S3TC.
		</div>

		<h3>[method:number getMaxAnisotropy]()</h3>
		<div>
		This returns the anisotropy level of the textures.
		</div>

		<h3>[method:string getPrecision]()</h3>
		<div>
		This gets the precision used by the shaders. It returns "highp","mediump" or "lowp".
		</div>

		<h3>[method:null setMaterialFaces]([page:Material material])</h3>
		<div>
		material -- The [page:Material material] with side that shouldn't be culled.
		</div>
		<div>
		This sets which side needs to be culled in the webgl renderer.
		</div>

		<h3>[method:boolean supportsStandardDerivatives]()</h3>
		<div>
		This method returns true if the webgl implementation supports standard derivatives.
		</div>

		<h3>[method:boolean supportsFloatTextures]()</h3>
		<div>
		This method returns true if the webgl implementation supports float textures.
		</div>

		<h3>[method:null clearTarget]([page:WebGLRenderTarget renderTarget], [page:boolean color], [page:boolean depth], [page:boolean stencil])</h3>
		<div>
		renderTarget -- The [page:WebGLRenderTarget renderTarget] that needs to be cleared.<br />
		color -- If set, then the color gets cleared. <br />
		depth -- If set, then the depth gets cleared. <br />
		stencil -- If set, then the stencil gets cleared.
		</div>
		<div>
		This method clears a rendertarget. To do this, it activates the rendertarget.
		</div>

		<h2>Source</h2>

		[link:https://github.com/mrdoob/three.js/blob/master/src/[path].js src/[path].js]
	</body>
</html>
